import random
import string
import aiohttp
import time
from pyrogram import filters
from Bot import app, Command
from Bot.database.grabtokendb import add_grab_token, get_current_ist_date
from Bot.utils import command_filter, warned_user_filter
from Bot.database.redeemdb import (
    create_redeem_code_shortner,
    get_redeem_code_shortner,
    claim_redeem_code_shortner,
    get_user_daily_usage_shortner,
    cleanup_expired_codes_shortner
)
from Bot.config import REDEEM_AMOUNT , API_TOKEN



SHORTENER_API_URL = "https://linkshortify.com/api"

DAILY_LIMIT = 5

# Generate a unique redeem code
async def generate_unique_redeem_code(length=10):
    characters = string.ascii_uppercase + string.digits
    while True:
        code = ''.join(random.choice(characters) for _ in range(length))
        existing_code = await get_redeem_code_shortner(code)
        if not existing_code:
            return code

# Shorten URL using the LinkShortify API
async def shorten_url(url):
    # Check if API token is available
    if not API_TOKEN:
        print("Warning: API_TOKEN environment variable not set")
        return None
        
    params = {
        "api": API_TOKEN,
        "url": url,
        "format": "json"
    }
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(SHORTENER_API_URL, params=params, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    if data.get("status") == "success":
                        return data.get("shortenedUrl")
                    else:
                        print(f"Error from LinkShortify API: {data.get('message', 'Unknown error')}")
                        return None
                else:
                    print(f"Error from LinkShortify API: HTTP {response.status}")
                    return None
    except aiohttp.ClientError as e:
        print(f"Network error when shortening URL: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error shortening URL: {e}")
        return None

@app.on_message(Command("tget") & command_filter & filters.private)
@warned_user_filter
async def tget_command(client, message):
    user_id = message.from_user.id
    user_name = message.from_user.first_name
    current_date = get_current_ist_date()  # Ensure date is in IST
    
    # Check daily limit using database with date check
    daily_usage = await get_user_daily_usage_shortner(user_id, current_date)  # Pass current IST date
    if daily_usage >= DAILY_LIMIT:
        await message.reply_text(f"âŒ You've reached your daily limit of {DAILY_LIMIT} token codes. Try again tomorrow!")
        return
    
    # Generate a unique redeem code
    redeem_code = await generate_unique_redeem_code()
    
    # Store the code in database (removed current_date parameter)
    await create_redeem_code_shortner(redeem_code, user_id, REDEEM_AMOUNT, user_name)
    
    redeem_url = f"https://t.me/{(await client.get_me()).username}?start=redeem_{redeem_code}"
    
    # Shorten the URL
    shortened_url = await shorten_url(redeem_url)
    
    if shortened_url:
        await message.reply_text(
            f"ğŸ **Token Redeem Code Generated!**\n\n"
            f"Click the link below to get your redeem code worth {REDEEM_AMOUNT:,} GrabTokens:\n\n"
            f"ğŸ”— {shortened_url}\n\n"
            f"âš ï¸ This is attempt {daily_usage + 1}/{DAILY_LIMIT} for today.\n"
            f"â³ Redeem codes expire after 24 hours.\n"
            f"â„¹ï¸ Note: Only you can redeem this code."
        )
    else:
        # Fallback if URL shortening fails - provide direct redeem command
        await message.reply_text(f"âŒ Failed to shorten URL. Please try again later.")


@app.on_message(Command("tredeem") & command_filter)
@warned_user_filter
async def tredeem_command(client, message):
    if len(message.command) != 2:
        await message.reply_text("âŒ Please provide a redeem code. Usage: `/tredeem CODE`")
        return
    
    redeem_code = message.command[1].upper()
    user_id = message.from_user.id
    user_name = message.from_user.first_name
    
    # Check if code exists in database
    code_data = await get_redeem_code_shortner(redeem_code)
    if not code_data:
        await message.reply_text("âŒ Invalid redeem code. Please check and try again.")
        return
    
    # Check if the code was generated by the same user
    if code_data["user_id"] != user_id:
        await message.reply_text("âŒ You can only redeem codes that you have generated yourself.")
        return
    
    # Check if code is already claimed
    if code_data["claimed"]:
        await message.reply_text("âŒ This code has already been redeemed.")
        return
    
    # Check if code is expired (24 hours)
    if time.time() - code_data["created_at"] > 86400:  # 24 hours in seconds
        await message.reply_text("âŒ This redeem code has expired.")
        return
    
    # Mark code as claimed in database
    updated_code = await claim_redeem_code_shortner(redeem_code, user_id, user_name)
    if not updated_code:
        await message.reply_text("âŒ Failed to redeem code. It may have been claimed by someone else.")
        return
    
    y = code_data["amount"]
    
    x = int(y)
    
    if x:
        await add_grab_token(user_id, x, user_name)
    else:
        await message.reply_text("âŒ Failed to redeem code.")
        return
    
    
    
    
    await message.reply_text(
        f"ğŸ‰ **Success!** You've redeemed {code_data['amount']:,} GrabTokens!\n\n"
        f"ğŸ’° The tokens have been added to your account.\n"
        f"ğŸ”„ Use /balance to check your updated balance."
    )

# Handle redeem via deep link
@app.on_message(filters.regex(r"^/start redeem_([A-Z0-9]+)$") & filters.private)
async def handle_redeem_deeplink(client, message):
    redeem_code = message.matches[0].group(1)
    user_id = message.from_user.id
    user_name = message.from_user.first_name
    
    # Check if code exists in database
    code_data = await get_redeem_code_shortner(redeem_code)
    if not code_data:
        await message.reply_text("âŒ Invalid redeem code. Please check and try again.")
        return
    
    # Check if the code was generated by the same user
    if code_data["user_id"] != user_id:
        await message.reply_text("âŒ You can only redeem codes that you have generated yourself.")
        return
    
    # Check if code is already claimed
    if code_data["claimed"]:
        await message.reply_text("âŒ This code has already been redeemed.")
        return
    
    # Check if code is expired (24 hours)
    if time.time() - code_data["created_at"] > 86400:  # 24 hours in seconds
        await message.reply_text("âŒ This redeem code has expired.")
        return
    
    # Mark code as claimed in database
    updated_code = await claim_redeem_code_shortner(redeem_code, user_id, user_name)
    if not updated_code:
        await message.reply_text("âŒ Failed to redeem code. It may have been claimed by someone else.")
        return
    
    y = code_data["amount"]
    x = int(y)
    
    if x:
        await add_grab_token(user_id, x, user_name)
    else:
        await message.reply_text("âŒ Failed to redeem code.")
        return
    
    await message.reply_text(
        f"ğŸ‰ **Success!** You've redeemed {code_data['amount']:,} GrabTokens!\n\n"
        f"ğŸ’° The tokens have been added to your account.\n"
        f"ğŸ”„ Use /balance to check your updated balance."
    )


async def scheduled_cleanup():
    deleted_count = await cleanup_expired_codes_shortner()
    print(f"Cleaned up {deleted_count} expired redeem codes")



    
